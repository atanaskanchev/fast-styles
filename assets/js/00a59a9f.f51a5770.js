"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[240],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var o=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=o.createContext({}),p=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return o.createElement(l.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},m=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=p(n),m=a,h=d["".concat(l,".").concat(m)]||d[m]||u[m]||r;return n?o.createElement(h,i(i({ref:t},c),{},{components:n})):o.createElement(h,i({ref:t},c))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,i=new Array(r);i[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:a,i[1]=s;for(var p=2;p<r;p++)i[p]=n[p];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}m.displayName="MDXCreateElement"},8583:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>p});var o=n(7462),a=(n(7294),n(3905));const r={sidebar_position:4,description:"Custom styles for every case"},i="Variants",s={unversionedId:"basics/variants",id:"basics/variants",title:"Variants",description:"Custom styles for every case",source:"@site/docs/basics/variants.md",sourceDirName:"basics",slug:"/basics/variants",permalink:"/fast-styles/docs/basics/variants",draft:!1,tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4,description:"Custom styles for every case"},sidebar:"mainSidebar",previous:{title:"Getting Started",permalink:"/fast-styles/docs/basics/getting-started"},next:{title:"Style Props",permalink:"/fast-styles/docs/basics/style-props"}},l={},p=[{value:"Adding Variants to your component",id:"adding-variants-to-your-component",level:2},{value:"Default variants",id:"default-variants",level:2},{value:"Compound Variants",id:"compound-variants",level:2},{value:"Variants and Nested Components",id:"variants-and-nested-components",level:2},{value:"To Conclude",id:"to-conclude",level:2}],c={toc:p},d="wrapper";function u(e){let{components:t,...n}=e;return(0,a.kt)(d,(0,o.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"variants"},"Variants"),(0,a.kt)("p",null,"Fast Styles supports ",(0,a.kt)("strong",{parentName:"p"},"variants"),", which allows you to define different styles for a component based on specific variations or conditions."),(0,a.kt)("p",null,"Variants are a fundamental part of this library, and they are designed to offer ",(0,a.kt)("strong",{parentName:"p"},"maximum performance"),", surpassing other libraries or even react-native vanilla."),(0,a.kt)("h2",{id:"adding-variants-to-your-component"},"Adding Variants to your component"),(0,a.kt)("p",null,"Let's assume that we want to enhance the button we created earlier and add the ",(0,a.kt)("inlineCode",{parentName:"p"},"colorScheme")," variant. This variant allows the user to choose a predefined color scheme for the button. In this case, we will add the options ",(0,a.kt)("inlineCode",{parentName:"p"},"primary"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"positive"),", and ",(0,a.kt)("inlineCode",{parentName:"p"},"negative"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"live noInline",live:!0,noInline:!0},'const ButtonRoot = styled(TouchableOpacity, {\n  display: "flex",\n  flexDirection: "row",\n  justifyContent: "center",\n  alignItems: "center",\n  width: 200,\n  padding: 12,\n  // You need to define the variants attribute.\n  // Each key you add will represent a variant\n  variants: {\n    colorScheme: {\n      // Each attribute in the variant will be a possible option to choose from.\n      // Here we will define the styles for "primary"\n      primary: {\n        backgroundColor: "#087ea4",\n      },\n      positive: {\n        backgroundColor: "#527717",\n      },\n      negative: {\n        backgroundColor: "#ff393f",\n      },\n    },\n  },\n});\n\nconst ButtonText = styled(Text, {\n  color: "#fbfbfb",\n  fontWeight: 700,\n});\n\nrender(\n  // Then you can assign the variant directly as a property.\n  // Try choosing another value, such as "primary" or "negative"!\n  <ButtonRoot colorScheme="negative">\n    <ButtonText>Button</ButtonText>\n  </ButtonRoot>\n);\n')),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"All the examples in this guide use a live editor. You can try the examples in real-time and see how the code behaves. Feel free to make changes and experiment with different styles.")),(0,a.kt)("h2",{id:"default-variants"},"Default variants"),(0,a.kt)("p",null,"If you don't define any ",(0,a.kt)("strong",{parentName:"p"},"default variants"),", Fast Styles will take the first option you have defined for each variant as the default. However, if you wish, you can set default variants using the ",(0,a.kt)("inlineCode",{parentName:"p"},"defaultVariants")," attribute:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},'const ButtonRoot = styled(TouchableOpacity, {\n  //...\n  defaultVariants: {\n    colorScheme: "primary",\n  },\n});\n')),(0,a.kt)("h2",{id:"compound-variants"},"Compound Variants"),(0,a.kt)("p",null,"Fast Styles goes beyond supporting basic variants and also includes ",(0,a.kt)("strong",{parentName:"p"},"compound variants"),". Compound variants are a powerful feature that allows you to define styles based on combinations of multiple variations."),(0,a.kt)("p",null,"For example, you can create styles for a button that is both ",(0,a.kt)("inlineCode",{parentName:"p"},"outlined")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"primary"),", or ",(0,a.kt)("inlineCode",{parentName:"p"},"solid")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"primary"),". This provides you with finer control over the styles applied to your components, making them highly versatile and customizable."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"live noInline",live:!0,noInline:!0},'const ButtonRoot = styled(TouchableOpacity, {\n  display: "flex",\n  flexDirection: "row",\n  justifyContent: "center",\n  alignItems: "center",\n  width: 200,\n  padding: 12,\n  variants: {\n    // We have added the "type" variant that allows you to define whether\n    // the button will be solid or outline.\n    type: {\n      solid: {},\n      outline: {\n        borderWidth: 1,\n      },\n    },\n    // Now, the style applied by the color scheme depends on the button type,\n    // so we will define it in compound variants.\n    colorScheme: {\n      primary: {},\n      positive: {},\n      negative: {},\n    },\n  },\n  //To define styles for a combination of variants, you just need to create a rule\n  //by concatenating the involved variants with a \'+\'.\n  compoundVariants: {\n    "outline+primary": {\n      borderColor: "#087ea4",\n    },\n    "outline+positive": {\n      borderColor: "#527717",\n    },\n    "outline+negative": {\n      borderColor: "#ff393f",\n    },\n    "solid+primary": {\n      backgroundColor: "#087ea4",\n    },\n    "solid+positive": {\n      backgroundColor: "#527717",\n    },\n    "solid+negative": {\n      backgroundColor: "#ff393f",\n    },\n  },\n});\n\nconst ButtonText = styled(Text, {\n  color: "#fbfbfb",\n  fontWeight: 700,\n});\n\nrender(\n  <ButtonRoot type="outline" colorScheme="negative">\n    <ButtonText>Button</ButtonText>\n  </ButtonRoot>\n);\n')),(0,a.kt)("h2",{id:"variants-and-nested-components"},"Variants and Nested Components"),(0,a.kt)("p",null,"In the previous section, we mentioned that Fast Styles avoids using ",(0,a.kt)("strong",{parentName:"p"},"underscore props")," to pass props to child components. This is because it's easy to ensure that child components respond to the same variant."),(0,a.kt)("p",null,"This approach makes each component responsible for its own changes, simplifying component creation and keeping the code clean."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"live noInline",live:!0,noInline:!0},'// the button root defined in the previous example\nconst ButtonRoot = PreviouslyDefinedButtonRoot;\n\n// The text component will respond to the colorScheme variant\nconst ButtonText = styled(Text, {\n  color: "#fbfbfb",\n  fontWeight: 700,\n  variants: {\n    type: {\n      solid: {\n        color: "white",\n      },\n      outline: {},\n    },\n    colorScheme: {\n      primary: {\n        color: "#087ea4",\n      },\n      positive: {\n        color: "#527717",\n      },\n      negative: {\n        color: "#ff393f",\n      },\n    },\n  },\n});\n\n// Let\'s create a button component composed of the TouchableOpacity and Text components\nconst Button = (props) => (\n  <ButtonRoot type={props.type} colorScheme={props.colorScheme}>\n    <ButtonText type={props.type} colorScheme={props.colorScheme}>\n      {props.children}\n    </ButtonText>\n  </ButtonRoot>\n);\n\n// If you try changing a variant, it will modify both the container and the text together\nrender(\n  <Button type="outline" colorScheme="negative">\n    Button\n  </Button>\n);\n')),(0,a.kt)("h2",{id:"to-conclude"},"To Conclude"),(0,a.kt)("p",null,"At this point, we have already seen how to create and use basic ",(0,a.kt)("strong",{parentName:"p"},"variants")," and ",(0,a.kt)("strong",{parentName:"p"},"compound variants"),"."),(0,a.kt)("p",null,"In the examples, we created a button and demonstrated the functionality by changing colors.\nHowever, you might wonder if all this is necessary just to define a color. ",(0,a.kt)("u",null,"The answer is no.")," If your component has a few properties that will change with each use, fast styles provides a way to map these properties to styles called ",(0,a.kt)("inlineCode",{parentName:"p"},"styleProps"),", and we will explore that in the next section."))}u.isMDXComponent=!0}}]);